import chisel3._
import chisel3.experimental.BundleLiterals._
import utils.Config._
import execution.StypeBaseAddress._
import execution.{StypeBaseAddress, StypeMod}

package object memory {

  val baseAddresses: Array[StypeBaseAddress.Type] = Array(X, XPHYS, XNEW, DC, DV, F, U, R, Z, P, Q, INVD, TMP)

  /**
   * Compute the indices of the of the 24 degrees of freedom associated with the 8 corners of the element at (i,j,k) in the grid.
   *
   * @param i Current coordinate in the x-direction
   * @param j Current coordinate in the y-direction
   * @param k Current coordinate in the z-direction
   * @return An array of 24 integers holding the 24 DOF's of the specified element
   */
  def getEdof(i: Int, j: Int, k: Int): Array[Int] = {
    if(i == -1 && j == -1 && k == -1) { //Shorthand for elements outside of grid
      return Array.fill(24)(-1)
    }
    require(0 <= i && i < NELX, "i must be in the range [0;NELX[")
    require(0 <= j && j < NELY, "j must be in the range [0;NELY[")
    require(0 <= k && k < NELZ, "k must be in the range [0;NELZ[")
    val NYL = NY/2
    val NZL = NZ/2
    val NYH = (NY+1)/2
    val NZH = (NZ+1)/2

    val nx0 = i/2
    val nx1 = i/2 + (i & 1)
    val ny0 = j/2
    val ny1 = j/2 + (j & 1)
    val nz0 = k/2
    val nz1 = k/2 + (k & 1)

    //Calculate nIndices
    val nIndex = Array.ofDim[Int](8)
    val edof = Array.ofDim[Int](24)

    nIndex(0) = nx1 * NYH * NZH + nz1 * NYH + ny1
    nIndex(1) = nx1 * NYL * NZH + nz1 * NYL + ny0
    nIndex(2) = nx1 * NYH * NZL + nz0 * NYH + ny1
    nIndex(3) = nx1 * NYL * NZL + nz0 * NYL + ny0
    nIndex(4) = nx0 * NYH * NZH + nz1 * NYH + ny1
    nIndex(5) = nx0 * NYL * NZH + nz1 * NYL + ny0
    nIndex(6) = nx0 * NYH * NZL + nz0 * NYH + ny1
    nIndex(7) = nx0 * NYL * NZL + nz0 * NYL + ny0

    for(i <- 0 until 8) {
      for(j <- 0 until 3) {
        edof(j*8+i) = nIndex(i)*24 + j*8 + i
      }
    }
    edof
  }

  /**
   * Compute the indices of the of the 24 degrees of freedom associated with the 8 corners of the element at (i,j,k) in the grid.
   * If an index does not correspond to a fixed DOF, returns -1 for that index instead
   *
   * @param i Current coordinate in the x-direction
   * @param j Current coordinate in the y-direction
   * @param k Current coordinate in the z-direction
   * @return An array of 24 integers holding the 24 DOF's of the specified element
   */
  def getFdof(i: Int, j: Int, k: Int): Array[Int] = {
    val edof = getEdof(i,j,k)
    //We always know that 4-7, 12-15 and 21-24 are 0
    val r = if(i == 0) { //There are some fixed dofs
      edof.grouped(4).zipWithIndex.flatMap[Int](e => if(e._2 % 2 == 0) e._1 else Seq(-1,-1,-1,-1)).toArray
    } else {
      Array.fill[Int](24)(-1)
    }
    r
  }

  /**
   * Compute the indices of the of the 24 degrees of freedom associated with the 8 corners of the element at (i,j,k) in the grid.
   *
   * @param inp A sequence of IJKgeneratorConsumerIO objects which all have their i,j,k-value set
   * @return A sequence of Array[Int], the array at position (x) holding the 24 edof values for the input at position (x)
   */
  def getEdof(inp: Seq[IJKgeneratorConsumerIO]): Seq[Array[Int]] = {
    inp.map(a => getEdof(a.ijk.i.litValue.toInt, a.ijk.j.litValue.toInt, a.ijk.k.litValue.toInt))
  }

  /**
   * A helper method used to sort element indices by their iteration/bank number
   * @param a The first value
   * @param b The second value
   * @return True if 'a' belongs to a lower iteration than b, false otherwise
   */
  def indexSort(a: Int, b: Int): Boolean = (a+8) % 8 < (b+8) % 8

  /**
   * Computes the 6 element indices associated with the 6 face neighbours of an element
   * @param ijk The i,j,k values of the central element for which the face neighbours should be calculated
   * @return A sequence of Ints holding the indices of the neighbours. If a neighbour does not exist, a negative value is returned instead.
   *         This negative value is generated by [[elementIndex]] and follows the rules thereof
   */
  def getFcnIndices(ijk: Array[Int]): Seq[Int] = {
    /** Generates a new array with i,j,k values offset from the input array */
    def offset(i: Int, j: Int, k: Int): Array[Int] = {
      Array(ijk(0)+i, ijk(1)+j, ijk(2)+k)
    }
    //Given ijk, we know exactly which and in what order will be fetched. Simply copy the behavior of the hardware
    val fcn1 = Array.fill(3)(0)
    val fcn2 = Array.fill(3)(0)
    fcn1(0) = elementIndex(offset(0,0,1))
    fcn1(1) = elementIndex(offset(0,1,0))
    fcn1(2) = elementIndex(offset(1,0,0))
    fcn2(0) = elementIndex(offset(0,0,-1))
    fcn2(1) = elementIndex(offset(0,-1,0))
    fcn2(2) = elementIndex(offset(-1,0,0))
    //We need to sort the subarrays by their index mod 8 to mimic the output of the address generator
    Array.concat(fcn1.sortWith(indexSort), fcn2.sortWith(indexSort))
  }

  /**
   * Computes the 6 element indices associated with the upper 6 face neighbours of an element
   * @param ijk The i,j,k values of the central element for which the edge neighbours should be calculated
   * @return A sequence of Ints holding the indices of the neighbours. If a neighbour does not exist, -1 is returned instead.
   *         These values are returned in the order that the memory stage will output them
   */
  def getEdn1Indices(ijk: Array[Int]): Seq[Int] = {
    /** Generates a new array with i,j,k values offset from the input array */
    def offset(i: Int, j: Int, k: Int): Array[Int] = {
      Array(ijk(0)+i, ijk(1)+j, ijk(2)+k)
    }
    //Given ijk, we know exactly which and in what order will be fetched. Simply copy the behavior of the hardware
    val fcn1 = Array.fill(3)(0)
    val fcn2 = Array.fill(3)(0)
    fcn1(0) = elementIndex(offset(0,1,1))
    fcn1(1) = elementIndex(offset(1,0,1))
    fcn1(2) = elementIndex(offset(1,1,0))
    fcn2(0) = elementIndex(offset(0,-1,1))
    fcn2(1) = elementIndex(offset(-1,0,1))
    fcn2(2) = elementIndex(offset(1,-1,0))
    //We need to sort the subarrays by their index mod 8 to mimic the output of the address generator
    Array.concat(fcn1.sortWith(indexSort), fcn2.sortWith(indexSort))
  }

  /**
   * Computes the 6 element indices associated with the upper 6 face neighbours of an element
   * @param ijk The i,j,k values of the central element for which the edge neighbours should be calculated
   * @return A sequence of Ints holding the indices of the neighbours. If a neighbour does not exist, -1 is returned instead.
   *         These values are returned in the order that the memory stage will output them
   */
  def getEdn2Indices(ijk: Array[Int]): Seq[Int] = {
    /** Generates a new array with i,j,k values offset from the input array */
    def offset(i: Int, j: Int, k: Int): Array[Int] = {
      Array(ijk(0)+i, ijk(1)+j, ijk(2)+k)
    }
    //Given ijk, we know exactly which and in what order will be fetched. Simply copy the behavior of the hardware
    val fcn1 = Array.fill(3)(0)
    val fcn2 = Array.fill(3)(0)
    fcn1(0) = elementIndex(offset(0,1,-1))
    fcn1(1) = elementIndex(offset(1,0,-1))
    fcn1(2) = elementIndex(offset(-1,1,0))
    fcn2(0) = elementIndex(offset(0,-1,-1))
    fcn2(1) = elementIndex(offset(-1,0,-1))
    fcn2(2) = elementIndex(offset(-1,-1,0))
    //We need to sort the subarrays by their index mod 8 to mimic the output of the address generator
    val sorted = Array.concat(fcn1.sortWith(indexSort), fcn2.sortWith(indexSort))
    sorted
  }

  /**
   * Generates a valid pair of ijk-coordinates
   * @return An IJK-coordinate tuple. At (0) is the i-value, at (1) the j-value and (2) the k-value. At (3) is the matching iteration number if necessary
   */
  def genIJK(): Array[Int] = {
    val rand = scala.util.Random
    val i = rand.nextInt(NELX)
    val j = rand.nextInt(NELY)
    val k = rand.nextInt(NELZ)
    val ijk = Array(i, j, k)

    //Generate iteration value
    val iter = iterationFromIJK(ijk)
    Array.concat(ijk, Array(iter))
  }

  /**
   * Calculates the iteration number for a given IJK-coordinate pair.
   * @param ijk The coordinate pair to get the iteration number for
   * @return The iteration number
   * @throws IllegalArgumentException If ijk does not have exactly 3 elements
   */
  def iterationFromIJK(ijk: Array[Int]): Int = {
    require(ijk.length == 3, "ijk must have exactly 3 elements to calculate the iteration value")
    ijk.map(e => (e+2) % 2) match { //Must add 2 to ensure that elements with value -1 from neighbour lookup still match correctly
      case Array(0,0,0) => 0
      case Array(0,1,0) => 1
      case Array(0,0,1) => 2
      case Array(0,1,1) => 3
      case Array(1,0,0) => 4
      case Array(1,1,0) => 5
      case Array(1,0,1) => 6
      case Array(1,1,1) => 7
    }
  }

  /**
   * Given an iteration number, returns the start mapping (the starting values for i, j and k for that ieration)
   * @param iter The iteration number
   * @return The start values for i,j,k for that iteration
   */
  def iterStartMap(iter: Int): Array[Int] = {
    iter match {
      case 0 => Array(0,0,0)
      case 1 => Array(0,1,0)
      case 2 => Array(0,0,1)
      case 3 => Array(0,1,1)
      case 4 => Array(1,0,0)
      case 5 => Array(1,1,0)
      case 6 => Array(1,0,1)
      case 7 => Array(1,1,1)
      case 8 => Array(-1,-1,-1)
      case _ => throw new IllegalArgumentException("No start mapping for iterations outside interval [0;8]")
    }
  }

  /**
   * Generates multiple IJK pairs which are sure to be in the order that the IJK generation module would traverse the grid
   * If IJK coordinates outside of the grid would be generated, returns (-1,-1,-1) instead
   * @param start An Option holding the i,j,k coordinates to start at, at positions (0), (1) and (2) respectively. If (3) is set, this is used as the iteration number.
   *              If None is given, generates a random i,j,k-coordinate pair to start at
   * @param elems The number of coordinate pairs to generate. Defaults to XREG_DEPTH
   * @return A sequence of arrays, each array holding the an i,j,k coordinate pair and their corresponding iteration value
   */
  def genIJKmultiple(start: Option[Array[Int]] = None, elems: Int = XREG_DEPTH): Seq[Array[Int]] = {
    val startVals = start match {
      case Some(x) => x
      case None => genIJK()
    }
    val i = startVals(0)
    val j = startVals(1)
    val k = startVals(2)
    val iter = if(startVals.length == 4) startVals(3) else iterationFromIJK(startVals)

    val ijkList = Array.ofDim[Array[Int]](elems)
    ijkList(0) = Array(i,j,k,iter)
    for(x <- 1 until elems) {
      ijkList(x) = nextIJK(ijkList(x-1))
    }
    ijkList
  }

  /**
   * Calculates the next ijk value to be accessed
   * @param ijkIter An array holding the i,j,k,iteration values at indices 0,1,2,3 respectively
   * @return Another ijkIter array, holding the indices and iteration values for the next ijk coordinates.
   *         If the next IJK coordinate is invalid, returns (-1, -1, -1, 8) instead
   */
  def nextIJK(ijkIter:  Array[Int]): Array[Int] = {
    val i = ijkIter(0)
    val j = ijkIter(1)
    val k = ijkIter(2)
    val iter = ijkIter(3)
    if(i == -1 && j == -1 && k == -1) {
      return Array(-1,-1,-1,8)
    }

    val jUpdate = j + 2 >= NELY
    val kUpdate = k + 2 >= NELZ
    val iUpdate = i + 2 >= NELX

    var jNext = j + 2
    var kNext = k
    var iNext = i
    var iterNext = iter

    if(jUpdate) {
      jNext = j % 2
      kNext = k + 2
    }
    if(jUpdate && kUpdate) {
      kNext = k % 2
      iNext = i + 2
    }
    if(jUpdate && kUpdate && iUpdate) {
      iterNext = iter + 1
      val startMap = iterStartMap(iterNext)
      iNext = startMap(0)
      jNext = startMap(1)
      kNext = startMap(2)
    }
    Array(iNext, jNext, kNext, iterNext)
  }

  /**
   * Calculates the global element index associated with an element's i,j,k coordinates
   * @param ijk An array holding the ijk coordinates at (0), (1) and (2) respectively
   * @return The element index of that element. If the given coordinates do not map to a valid element,
   *         a negative value is returned instead. If 8 is added to this negative value, it should still be possible
   *         to sort a list of face/edge neighbours
   */
  def elementIndex(ijk: Array[Int]): Int = {
    val i = ijk(0)
    val j = ijk(1)
    val k = ijk(2)
    // (i/2*NELYH*NELZH + k/2*NELYH + j/2) << 3 | iteration
    val e = (i/2*((NELY+1)/2)*((NELZ+1)/2) + k/2*((NELY+1)/2) + j/2)*NUM_MEMORY_BANKS + iterationFromIJK(Array(i,j,k))
    if(i < 0 || i >= NELX || j < 0 || j >= NELY || k < 0 || k >= NELZ) {(e % 8) - 8} else e
  }

  /**
   * Given an array, returns a random element from that array
   * @param arr The array to extract a random element from
   * @tparam T The type of the array. Any type is valid
   * @return A random element that is in arr
   */
  def randomElement[T <: Any](arr: Array[T]): T = {
    arr(scala.util.Random.nextInt(arr.length))
  }

  /**
   * Generates an IJK input bundle for poking onto the DUT
   * @param IJK An Option holding the IJK coordinates of the instruction. If None is given, generates a random ijk-coordinate pair. Defaults to None
   * @param baseAddress An Option holding the base address of the instruction. If None is given, selects a random base address. Defaults to None
   * @param pad Padding flag
   * @param mod S-type modifier for the instruction
   * @return An IJKGeneratorConsumerIO Bundle, ready to poke onto the IJK input port of the memory stage
   */
  def genIJKinput(IJK: Option[Array[Int]] = None, baseAddress: Option[StypeBaseAddress.Type] = None, pad: Boolean, mod: StypeMod.Type): IJKgeneratorConsumerIO = {
    val ijk = IJK match {
      case Some(x) => x
      case None => genIJK()
    }
    val baseAddr = baseAddress match {
      case Some(x) => x
      case None => randomElement(baseAddresses)
    }
    val ijkBundle = (new IJKBundle).Lit(_.i -> ijk(0).U, _.j -> ijk(1).U, _.k -> ijk(2).U)
    (new IJKgeneratorConsumerIO).Lit(_.baseAddr -> baseAddr, _.ijk -> ijkBundle, _.pad -> pad.B, _.mod -> mod)
  }
}
