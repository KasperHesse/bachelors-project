package utils

import scala.io.Source

/**
 * Compares the contents of memory dump files generated by the C-program to memory dump
 * files generated by the simulator
 */
object MemoryCompare extends App {

  val testName = "simulator"
  val hash = "1"
  def apply(): Unit = {
//    val DV = compare("DV")
//    val DC = compare("DC")
//    val INVD = compare("INVD")
//    val R = compare("R")
//    val Z = compare("Z")
//    val P = compare("P")
//    val Q = compare("Q")
//    val U = compare("U")
//    val X = compare("X")
    val XPHYS = compare("XPHYS")
//    val XNEW = compare("XNEW")

    def print(x: (Int, Double, Int, Double), name: String): Unit = {
      println(f"$name%-6s| ${x._2}%14.8f | ${x._4}%9.5f | ${x._1}%4d | ${x._3}%4d")
    }

    println("NAME  | Avg. Delta     | Av.Delta2 |  cnt | Signerrors")
    println("------+----------------+-----------+------+-----------")
//    print(DV, "DV")
//    print(DC, "DC")
//    print(INVD, "INVD")
//    print(R, "R")
//    print(Z, "Z")
//    print(P, "P")
//    print(Q, "Q")
//    print(U, "U")
//    print(X, "X")
    print(XPHYS, "XPHYS")
//    print(XNEW, "XNEW")

  }

  /**
   *
   * @param name
   * @param delta
   * @return A tuple: (0) is number of miscompares, (1) is average absolute miscompare delta
   *         (2) is number of sign errors, (3) is average percentage miscompare delta
   */
  def compare(name: String, delta: Double = 0.0001): (Int, Double, Int, Double) = {

    val file1 = Source.fromFile(f"memdump/$testName/$hash/mem_$name.csv")
    val file2 = Source.fromFile(f"memdump_C/memdump_$name.csv")

    val lines1 = file1.getLines().toArray
    val lines2 = file2.getLines().toArray

    require(lines1.length == lines2.length, s"Files for [$name] must be of the same length. f1: ${lines1.length}, f2: ${lines2.length}")

    println(s"Comparing values for [$name]")
    //Remove first element (csv header), split at commas, take last element (value) and convert to double
    val SCALA = lines1.tail.map(_.split(",").last.toDouble)
    val C = lines2.tail.map(_.split(",").last.toDouble)
    var errCnt = 0
    var signCnt = 0
    var errAvg = 0.0

    //Calculate 2-norm difference
    val twonormc = norm(C)
    val twonormdiff = norm(C.zip(SCALA).map(x => x._1-x._2))
    val errAvg2 = twonormdiff/twonormc*100

    //Calculate absolute differences
    for(i <- C.indices) {
      val scala = SCALA(i)
      val c = C(i)

      if(math.abs(scala-c) > delta) {
        println(f"ERROR at $i. Scala: $scala%.8f, C: $c%.8f, Delta: ${math.abs(scala-c)}%.5f")
        errCnt += 1
        errAvg += math.abs(scala-c)
      }
      if(scala <= 0 && c > 0 || c <= 0 && scala > 0) {
        signCnt += 1
        println(f"SIGNERR at $i: Scala $scala%.5f, C $c%.5f")
      }
    }


    if(errCnt > 0) {
      errAvg = errAvg / errCnt
      println(f"$errCnt errors found for [$name] at delta=$delta")
      println(f"Average error: $errAvg%.5f")
    }
    println(f"Signcnt=$signCnt")

    println("Comparison finished\n\n")

    file1.close()
    file2.close()
    (errCnt, errAvg, signCnt, errAvg2)
  }

  /**
   * Calculates the 2-norm of a vector
   * @param V The vector
   * @return THe 2-norm
   */
  def norm(V: Array[Double]): Double = {
    var sum = 0.0
    for(v <- V) {
      sum += v*v
    }
    Math.sqrt(sum)
  }

  apply()
}
